<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="Guillaume Guénard" />
<meta name="author" content="Pierre Legendre" />

<meta name="date" content="2024-09-26" />

<title>Using pMEM for Spatial Modelling with Predictive Moran’s Eigenvector Maps</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
</style>



<style type="text/css">
code {
white-space: pre;
}
.sourceCode {
overflow: visible;
}
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } 
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.at { color: #7d9029; } 
code span.bn { color: #40a070; } 
code span.bu { color: #008000; } 
code span.cf { color: #007020; font-weight: bold; } 
code span.ch { color: #4070a0; } 
code span.cn { color: #880000; } 
code span.co { color: #60a0b0; font-style: italic; } 
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.do { color: #ba2121; font-style: italic; } 
code span.dt { color: #902000; } 
code span.dv { color: #40a070; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #40a070; } 
code span.fu { color: #06287e; } 
code span.im { color: #008000; font-weight: bold; } 
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.kw { color: #007020; font-weight: bold; } 
code span.op { color: #666666; } 
code span.ot { color: #007020; } 
code span.pp { color: #bc7a00; } 
code span.sc { color: #4070a0; } 
code span.ss { color: #bb6688; } 
code span.st { color: #4070a0; } 
code span.va { color: #19177c; } 
code span.vs { color: #4070a0; } 
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } 
</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>



<style type="text/css">

div.csl-bib-body { }
div.csl-entry {
clear: both;
margin-bottom: 0em;
}
.hanging div.csl-entry {
margin-left:2em;
text-indent:-2em;
}
div.csl-left-margin {
min-width:2em;
float:left;
}
div.csl-right-inline {
margin-left:2em;
padding-left:1em;
}
div.csl-indent {
margin-left: 2em;
}
</style>

<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Using pMEM for Spatial Modelling with
Predictive Moran’s Eigenvector Maps</h1>
<h4 class="author">Guillaume Guénard</h4>
<h4 class="author">Pierre Legendre</h4>
<h4 class="date">2024-09-26</h4>


<div id="TOC">
<ul>
<li><a href="#introduction" id="toc-introduction">Introduction</a></li>
<li><a href="#data-atlantic-salmon-parr-distribution" id="toc-data-atlantic-salmon-parr-distribution">Data: Atlantic salmon
parr distribution</a></li>
<li><a href="#calculations" id="toc-calculations">Calculations</a>
<ul>
<li><a href="#function-gensef" id="toc-function-gensef">Function
genSEF</a></li>
<li><a href="#function-getminmse" id="toc-function-getminmse">Function
getMinMSE</a></li>
<li><a href="#objective-function-for-parameter-search" id="toc-objective-function-for-parameter-search">Objective function for
parameter search</a></li>
<li><a href="#building-models-for-channel-depth-current-velocity-and-substrate-grain-size" id="toc-building-models-for-channel-depth-current-velocity-and-substrate-grain-size">Building
models for channel depth, current velocity, and substrate grain size</a>
<ul>
<li><a href="#channel-depth" id="toc-channel-depth">Channel
depth</a></li>
<li><a href="#current-velocity" id="toc-current-velocity">Current
velocity</a></li>
<li><a href="#substrate-grain-size" id="toc-substrate-grain-size">Substrate grain size</a></li>
</ul></li>
<li><a href="#atlantic-salmon-parr-abundance" id="toc-atlantic-salmon-parr-abundance">Atlantic salmon parr
abundance</a></li>
</ul></li>
<li><a href="#references" id="toc-references">References</a></li>
</ul>
</div>

<div id="introduction" class="section level1">
<h1>Introduction</h1>
<p>In the present paper, we show how to model the values of variables in
space using a representation of their spatial variation. These
representations are provided by predictive Moran’s eigenveector maps
(pMEM), an extension of Moran’s eigenvector maps <span class="citation">(Dray, Legendre, and Peres-Neto 2006)</span>, which
take their name from Moran’s autocorrelation index <span class="citation">(Moran 1948, 1950)</span>. For pMEM, we use a
simplified version of MEM whereby the connectivity is decided only by
the distance between the sampling locations. Also, package
<strong>pMEM</strong> implements functionalities, such as supplementary
distance weighting functions, that were not defined by <span class="citation">Dray, Legendre, and Peres-Neto (2006)</span> in their
original definition of the method.</p>
</div>
<div id="data-atlantic-salmon-parr-distribution" class="section level1">
<h1>Data: Atlantic salmon parr distribution</h1>
<p>The exemplary data set features observations (performed by
snorkelling) of the presence and numbers of Atlantic salmon parr
(juvenile) in <span class="math inline">\(76\)</span> <span class="math inline">\(20\,\mathrm{m}\)</span> river segments forming a
<span class="math inline">\(1\,520\,\mathrm{m}\)</span> transect of the
St. Marguerite River, Québec, Canada. Sampled together with these
observations were the channel depth (<span class="math inline">\(D\)</span>) the water velocity (<span class="math inline">\(V\)</span>), and mean substrate grain size (<span class="math inline">\(D_{50}\)</span>), which were taken at the thalweg
in the middle of each section (i.e., <span class="math inline">\(10\,\mathrm{m}\)</span> after the beginning and
<span class="math inline">\(10\,\mathrm{m}\)</span> before the end of
each section). Observations were performed while moving in the upstream
direction in a zigzag manner in order not to disturb the fish prior to
their observation. This data package is loaded in the <strong>R</strong>
environment as follows:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="fu">data</span>(<span class="st">&quot;salmon&quot;</span>, <span class="at">package =</span> <span class="st">&quot;pMEM&quot;</span>)</span></code></pre></div>
</div>
<div id="calculations" class="section level1">
<h1>Calculations</h1>
<p>Les us first load the necessary packages for this example:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a><span class="fu">library</span>(<span class="st">&quot;pMEM&quot;</span>)         <span class="do">## To calculate pMEM</span></span></code></pre></div>
<pre><code>## Le chargement a nécessité le package : sf</code></pre>
<pre><code>## Linking to GEOS 3.10.2, GDAL 3.4.1, PROJ 8.2.1; sf_use_s2() is TRUE</code></pre>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a><span class="fu">library</span>(<span class="st">&quot;magrittr&quot;</span>)     <span class="do">## For its very handy pipe operateur (%&gt;%)</span></span>
<span id="cb5-2"><a href="#cb5-2" tabindex="-1"></a><span class="fu">library</span>(<span class="st">&quot;glmnet&quot;</span>)       <span class="do">## To calculate elastic net regression</span></span></code></pre></div>
<pre><code>## Le chargement a nécessité le package : Matrix</code></pre>
<pre><code>## Loaded glmnet 4.1-8</code></pre>
<p>Packages <strong>magrittr</strong> and <strong>glmnet</strong> are
suggested package of <strong>pMEM</strong>, and are therefore not
automatically installed along with the latter. You may have to install
them manually in order to execute this example code. Also, we need to
draw indices for the training and the testing sets, which we are obtain
as follows:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">1234567890</span>)                     <span class="do">## For the drawing to be repeatable.</span></span>
<span id="cb8-2"><a href="#cb8-2" tabindex="-1"></a><span class="fu">sort</span>(<span class="fu">sample</span>(<span class="fu">nrow</span>(salmon),<span class="dv">25</span>)) <span class="ot">-&gt;</span> test    <span class="do">## Drawing the testing set (N = 25).</span></span>
<span id="cb8-3"><a href="#cb8-3" tabindex="-1"></a>(<span class="dv">1</span><span class="sc">:</span><span class="fu">nrow</span>(salmon))[<span class="sc">-</span>test] <span class="ot">-&gt;</span> train         <span class="do">## The training set is the remainder.</span></span></code></pre></div>
<p>Here, we set a random seed to a specific value to make subsequent
analyses repeatable. Feel free to skip this line, in which case your
results will differ somewhat from the ones that follows.</p>
<div id="function-gensef" class="section level2">
<h2>Function genSEF</h2>
<p>A pMEM is generated using function <code>genSEF()</code> as
follows:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a><span class="fu">genSEF</span>(</span>
<span id="cb9-2"><a href="#cb9-2" tabindex="-1"></a>  <span class="at">x =</span> salmon<span class="sc">$</span>Position[train],   <span class="do">## The set of locations.</span></span>
<span id="cb9-3"><a href="#cb9-3" tabindex="-1"></a>  <span class="at">m =</span> <span class="fu">genDistMetric</span>(),          <span class="do">## The distance metric function.</span></span>
<span id="cb9-4"><a href="#cb9-4" tabindex="-1"></a>  <span class="at">f =</span> <span class="fu">genDWF</span>(<span class="st">&quot;linear&quot;</span>, <span class="dv">500</span>)     <span class="do">## The distance weighting function.</span></span>
<span id="cb9-5"><a href="#cb9-5" tabindex="-1"></a>) <span class="ot">-&gt;</span> sef0</span>
<span id="cb9-6"><a href="#cb9-6" tabindex="-1"></a></span>
<span id="cb9-7"><a href="#cb9-7" tabindex="-1"></a>sef0                            <span class="do">## Show the resulting object.</span></span></code></pre></div>
<pre><code>## A SEMap-class object
## --------------------
## Number of sites: 51
## Directional: no
## Number of components: 50
## Eigenvalues: 12.36926,9.94984,5.29604,...,0.01169,0.00863
## --------------------</code></pre>
<p>For this call, argument <code>x</code> is the set of locations
coordinates; they are given to the distance metric function that is
given to <code>genSEF</code> through its argument <code>m</code>. In
this example, it is the returned value of function
<code>genDistMetric</code>. In this simple case,
<code>genDistMetric</code> is called without an argument and returns a
two argument function that calculate the Euclidean distance between the
elements (or rows) of the vectors or matrices given to these two
arguments. Argument <code>f</code> is also given a one argument spatial
weighting function; which take the distances and returning weights. The
later is generated by a function called <code>genDWF</code> that itself
has three arguments: <code>fun</code> which specify the type of
weighting function, <code>dmax</code> which specify the threshold
distance (or scale parameters when <code>fun</code> is one of
“exponential”, “Gaussian”, or “hole_effet”), and <code>shape</code> for
any additional shape parameters (currently used when <code>fun</code> is
one of “power” or “hyperbolic”). The shape of the resulting spatial
eigenfunctions can be shown as follows:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a><span class="do">## A regular transect of points 1 m apart:</span></span>
<span id="cb11-2"><a href="#cb11-2" tabindex="-1"></a>salmon<span class="sc">$</span>Position <span class="sc">%&gt;%</span></span>
<span id="cb11-3"><a href="#cb11-3" tabindex="-1"></a>  {<span class="fu">seq</span>(<span class="fu">min</span>(.) <span class="sc">-</span> <span class="dv">20</span>, <span class="fu">max</span>(.) <span class="sc">+</span> <span class="dv">20</span>, <span class="dv">1</span>)} <span class="ot">-&gt;</span> xx</span>
<span id="cb11-4"><a href="#cb11-4" tabindex="-1"></a></span>
<span id="cb11-5"><a href="#cb11-5" tabindex="-1"></a><span class="do">## Custom plotting function:</span></span>
<span id="cb11-6"><a href="#cb11-6" tabindex="-1"></a>plotSEF <span class="ot">&lt;-</span> <span class="cf">function</span>(sef, xTrain, xTest, xx, wh, ...) {</span>
<span id="cb11-7"><a href="#cb11-7" tabindex="-1"></a>  <span class="fu">plot</span>(<span class="at">x =</span> xx, <span class="at">y =</span> <span class="fu">predict</span>(sef, xx, wh), <span class="at">type =</span> <span class="st">&quot;l&quot;</span>, ...)</span>
<span id="cb11-8"><a href="#cb11-8" tabindex="-1"></a>  <span class="fu">points</span>(<span class="at">x =</span> xTrain, <span class="at">y =</span> <span class="fu">as.matrix</span>(sef, wh), <span class="at">pch=</span><span class="dv">21</span>, <span class="at">bg=</span><span class="st">&quot;black&quot;</span>)</span>
<span id="cb11-9"><a href="#cb11-9" tabindex="-1"></a>  <span class="fu">points</span>(<span class="at">x =</span> xTest, <span class="at">y =</span> <span class="fu">predict</span>(sef, xTest)[,wh], <span class="at">pch=</span><span class="dv">21</span>, <span class="at">bg=</span><span class="st">&quot;red&quot;</span>)</span>
<span id="cb11-10"><a href="#cb11-10" tabindex="-1"></a>  <span class="fu">invisible</span>(<span class="cn">NULL</span>)</span>
<span id="cb11-11"><a href="#cb11-11" tabindex="-1"></a>}</span>
<span id="cb11-12"><a href="#cb11-12" tabindex="-1"></a></span>
<span id="cb11-13"><a href="#cb11-13" tabindex="-1"></a><span class="do">## Storing the graphical parameters:</span></span>
<span id="cb11-14"><a href="#cb11-14" tabindex="-1"></a>p <span class="ot">&lt;-</span> <span class="fu">par</span>(<span class="at">no.readonly =</span> <span class="cn">TRUE</span>)</span>
<span id="cb11-15"><a href="#cb11-15" tabindex="-1"></a></span>
<span id="cb11-16"><a href="#cb11-16" tabindex="-1"></a><span class="do">## Changing the graphical parameters:</span></span>
<span id="cb11-17"><a href="#cb11-17" tabindex="-1"></a><span class="fu">par</span>(<span class="at">mfrow=</span><span class="fu">c</span>(<span class="dv">3</span>,<span class="dv">2</span>), <span class="at">mar=</span><span class="fu">c</span>(<span class="fl">4.6</span>,<span class="fl">4.6</span>,<span class="dv">3</span>,<span class="dv">1</span>))</span>
<span id="cb11-18"><a href="#cb11-18" tabindex="-1"></a></span>
<span id="cb11-19"><a href="#cb11-19" tabindex="-1"></a><span class="do">## Generate a six-inset plot:</span></span>
<span id="cb11-20"><a href="#cb11-20" tabindex="-1"></a><span class="cf">for</span>(fun <span class="cf">in</span> <span class="fu">c</span>(<span class="st">&quot;power&quot;</span>,<span class="st">&quot;hyperbolic&quot;</span>,<span class="st">&quot;spherical&quot;</span>,<span class="st">&quot;exponential&quot;</span>,<span class="st">&quot;Gaussian&quot;</span>,</span>
<span id="cb11-21"><a href="#cb11-21" tabindex="-1"></a>             <span class="st">&quot;hole_effect&quot;</span>))</span>
<span id="cb11-22"><a href="#cb11-22" tabindex="-1"></a>  <span class="fu">genSEF</span>(</span>
<span id="cb11-23"><a href="#cb11-23" tabindex="-1"></a>    <span class="at">x =</span> salmon<span class="sc">$</span>Position[train],</span>
<span id="cb11-24"><a href="#cb11-24" tabindex="-1"></a>    <span class="at">m =</span> <span class="fu">genDistMetric</span>(),</span>
<span id="cb11-25"><a href="#cb11-25" tabindex="-1"></a>    <span class="at">f =</span> <span class="fu">genDWF</span>(fun, <span class="dv">250</span>, <span class="fl">0.75</span>)</span>
<span id="cb11-26"><a href="#cb11-26" tabindex="-1"></a>  ) <span class="sc">%&gt;%</span></span>
<span id="cb11-27"><a href="#cb11-27" tabindex="-1"></a>    <span class="fu">plotSEF</span>(salmon<span class="sc">$</span>Position[train], salmon<span class="sc">$</span>Position[test], xx, <span class="dv">1</span>,</span>
<span id="cb11-28"><a href="#cb11-28" tabindex="-1"></a>            <span class="at">xlab=</span><span class="st">&quot;Location (m)&quot;</span>, <span class="at">ylab=</span><span class="st">&quot;pMEM score&quot;</span>, <span class="at">main=</span>fun, <span class="at">lwd=</span><span class="dv">2</span>)</span></code></pre></div>
<p><img role="img" src="data:image/png;base64,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" /><!-- -->
Fig. 1. Examples of pMEM spatial eigenfunctions of order 1 with
descriptor (back markers) and prediction scores (red markers). The black
continuous line is calculated for 1-m intervals to show the continuity
of the spatial eigenfunctions.</p>
<hr />
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" tabindex="-1"></a><span class="do">## Restoring the graphical parameters:</span></span>
<span id="cb12-2"><a href="#cb12-2" tabindex="-1"></a><span class="fu">par</span>(p)</span></code></pre></div>
</div>
<div id="function-getminmse" class="section level2">
<h2>Function getMinMSE</h2>
<p>Another function that we need to introduce before proceeding any
further is called <code>getMinMSE()</code> and is a utility function for
fitting simple linear models involving only SEFs and a single
normally-distributed response variables. It needs a training and a
testing set and search for set of SEF that, when fitted in the training
set allows one to best predict the values of the testing set. Also, it
is implemented in C++ through the <strong>Rcpp</strong> package and thus
runs very fast. Function <code>getMinMSE()</code> is called as
follows:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a><span class="fu">getMinMSE</span>(</span>
<span id="cb13-2"><a href="#cb13-2" tabindex="-1"></a>  <span class="at">U =</span> <span class="fu">as.matrix</span>(sef0),</span>
<span id="cb13-3"><a href="#cb13-3" tabindex="-1"></a>  <span class="at">y =</span> salmon<span class="sc">$</span>Depth[train],</span>
<span id="cb13-4"><a href="#cb13-4" tabindex="-1"></a>  <span class="at">Up =</span> <span class="fu">predict</span>(sef0, salmon<span class="sc">$</span>Position[test]),</span>
<span id="cb13-5"><a href="#cb13-5" tabindex="-1"></a>  <span class="at">yy =</span> salmon<span class="sc">$</span>Depth[test],</span>
<span id="cb13-6"><a href="#cb13-6" tabindex="-1"></a>  <span class="at">complete =</span> <span class="cn">FALSE</span></span>
<span id="cb13-7"><a href="#cb13-7" tabindex="-1"></a>)</span></code></pre></div>
<pre><code>## $betasq
## [1] 0.0009423604
## 
## $mse
## [1] 0.008758679</code></pre>
<p>From the documentation, arguments of that function are:</p>
<dl>
<dt><code>U</code></dt>
<dd>
A matrix of spatial eigenvectors to be used as training data.
</dd>
<dt><code>y</code></dt>
<dd>
A numeric vector containing a single response variable to be used as
training labels.
</dd>
<dt><code>Up</code></dt>
<dd>
A numeric matrix of spatial eigenvector scores to be used as testing
data.
</dd>
<dt><code>yy</code></dt>
<dd>
A numeric vector containing a single response variable to be used as
testing labels.
</dd>
<dt><code>complete</code></dt>
<dd>
A boolean specifying whether to return the complete data of the
selection procedure (<code>complete=TRUE</code>; the default) or only
the resulting mean square error and beta threshold
(<code>complete=FALSE</code>).
</dd>
</dl>
<p>Called with argument <code>complete=FALSE</code>, the function
returns only the (out of the sample) mean square error (MSE) of the
model and the minimum standardized regression coefficient of the model
used to obtain it.</p>
</div>
<div id="objective-function-for-parameter-search" class="section level2">
<h2>Objective function for parameter search</h2>
<p>Now that we have a mean to estimate simple models, we can muster a
way to estimate SEF parameter using an objective function such as the
following:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" tabindex="-1"></a>objf <span class="ot">&lt;-</span> <span class="cf">function</span>(par, m, fun, x, xx, y, yy, lb, ub) {</span>
<span id="cb15-2"><a href="#cb15-2" tabindex="-1"></a>  </span>
<span id="cb15-3"><a href="#cb15-3" tabindex="-1"></a>  <span class="do">## Bound the parameter values within the lb -&gt; ub intervals:</span></span>
<span id="cb15-4"><a href="#cb15-4" tabindex="-1"></a>  par <span class="ot">&lt;-</span> (ub <span class="sc">-</span> lb) <span class="sc">*</span> (<span class="dv">1</span> <span class="sc">+</span> <span class="fu">exp</span>(<span class="sc">-</span>par))<span class="sc">^</span>(<span class="sc">-</span><span class="dv">1</span>) <span class="sc">+</span> lb</span>
<span id="cb15-5"><a href="#cb15-5" tabindex="-1"></a>  <span class="do">## This step is necessary to prevent pitfalls during optimization.</span></span>
<span id="cb15-6"><a href="#cb15-6" tabindex="-1"></a>  </span>
<span id="cb15-7"><a href="#cb15-7" tabindex="-1"></a>  <span class="do">## Calculate the SEF under the conditions requested</span></span>
<span id="cb15-8"><a href="#cb15-8" tabindex="-1"></a>  <span class="cf">if</span>(fun <span class="sc">%in%</span> <span class="fu">c</span>(<span class="st">&quot;power&quot;</span>,<span class="st">&quot;hyperbolic&quot;</span>)) {</span>
<span id="cb15-9"><a href="#cb15-9" tabindex="-1"></a>    sef <span class="ot">&lt;-</span> <span class="fu">genSEF</span>(x, m, <span class="fu">genDWF</span>(fun, <span class="at">range =</span> par[<span class="dv">1</span><span class="dt">L</span>], <span class="at">shape =</span> par[<span class="dv">2</span><span class="dt">L</span>]))</span>
<span id="cb15-10"><a href="#cb15-10" tabindex="-1"></a>  } <span class="cf">else</span></span>
<span id="cb15-11"><a href="#cb15-11" tabindex="-1"></a>    sef <span class="ot">&lt;-</span> <span class="fu">genSEF</span>(x, m, <span class="fu">genDWF</span>(fun, <span class="at">range =</span> par[<span class="dv">1</span><span class="dt">L</span>]))</span>
<span id="cb15-12"><a href="#cb15-12" tabindex="-1"></a>  </span>
<span id="cb15-13"><a href="#cb15-13" tabindex="-1"></a>  <span class="do">## Calculate the minMSE model</span></span>
<span id="cb15-14"><a href="#cb15-14" tabindex="-1"></a>  res <span class="ot">&lt;-</span> <span class="fu">getMinMSE</span>(<span class="fu">as.matrix</span>(sef), y, <span class="fu">predict</span>(sef, xx), yy, <span class="cn">FALSE</span>)</span>
<span id="cb15-15"><a href="#cb15-15" tabindex="-1"></a>  </span>
<span id="cb15-16"><a href="#cb15-16" tabindex="-1"></a>  <span class="do">## The objective criterion is the out of the sample mean squared error:</span></span>
<span id="cb15-17"><a href="#cb15-17" tabindex="-1"></a>  res<span class="sc">$</span>mse</span>
<span id="cb15-18"><a href="#cb15-18" tabindex="-1"></a>}</span></code></pre></div>
<p>Objective functions have a first argument called <code>par</code>
which is used to pass the parameter whose values are be optimized for
minimum returned value. The other arguments are the ones necessary for
the function to operate, but for which no optimization is carried on.
That function also applies boundaries to parameter values, which are
given by arguments <code>lb</code> (lower bounds) and <code>ub</code>
(upper bounds). This function can be used to perform global parameter
search as is called as follows (here, using the mean channel depth as an
example):</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" tabindex="-1"></a><span class="fu">objf</span>(</span>
<span id="cb16-2"><a href="#cb16-2" tabindex="-1"></a>  <span class="at">par =</span> <span class="fu">c</span>(<span class="dv">0</span>),</span>
<span id="cb16-3"><a href="#cb16-3" tabindex="-1"></a>  <span class="at">m =</span> <span class="fu">genDistMetric</span>(),</span>
<span id="cb16-4"><a href="#cb16-4" tabindex="-1"></a>  <span class="at">fun =</span> <span class="st">&quot;linear&quot;</span>,</span>
<span id="cb16-5"><a href="#cb16-5" tabindex="-1"></a>  <span class="at">x =</span> salmon<span class="sc">$</span>Position[train],</span>
<span id="cb16-6"><a href="#cb16-6" tabindex="-1"></a>  <span class="at">xx =</span> salmon<span class="sc">$</span>Position[test],</span>
<span id="cb16-7"><a href="#cb16-7" tabindex="-1"></a>  <span class="at">y =</span> salmon[[<span class="st">&quot;Depth&quot;</span>]][train],</span>
<span id="cb16-8"><a href="#cb16-8" tabindex="-1"></a>  <span class="at">yy =</span> salmon[[<span class="st">&quot;Depth&quot;</span>]][test],</span>
<span id="cb16-9"><a href="#cb16-9" tabindex="-1"></a>  <span class="at">lb =</span> <span class="fu">c</span>(<span class="dv">10</span>),</span>
<span id="cb16-10"><a href="#cb16-10" tabindex="-1"></a>  <span class="at">ub =</span> <span class="fu">c</span>(<span class="dv">1000</span>)</span>
<span id="cb16-11"><a href="#cb16-11" tabindex="-1"></a>) <span class="ot">-&gt;</span> res</span>
<span id="cb16-12"><a href="#cb16-12" tabindex="-1"></a></span>
<span id="cb16-13"><a href="#cb16-13" tabindex="-1"></a>res</span></code></pre></div>
<pre><code>## [1] 0.007957888</code></pre>
<p>which yields a channel depth model having a root mean square error of
<span class="math inline">\(0.0892\,\mathrm{m}\)</span>, or <span class="math inline">\(8.92\,\mathrm{cm}\)</span>.</p>
</div>
<div id="building-models-for-channel-depth-current-velocity-and-substrate-grain-size" class="section level2">
<h2>Building models for channel depth, current velocity, and substrate
grain size</h2>
<p>In the following section, we build three models that are purely
spatial, involving only pMEM spatial eigenfunctions. To simplify the
scripts, we will begin by creating lists for storing the results as
follows:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" tabindex="-1"></a>sefTrain <span class="ot">&lt;-</span> <span class="fu">list</span>()  <span class="do">## For storing the &quot;SEMap&quot; objects.</span></span>
<span id="cb18-2"><a href="#cb18-2" tabindex="-1"></a>mseRes <span class="ot">&lt;-</span> <span class="fu">list</span>()    <span class="do">## For storing results from function getMinMSE().</span></span>
<span id="cb18-3"><a href="#cb18-3" tabindex="-1"></a>sel <span class="ot">&lt;-</span> <span class="fu">list</span>()       <span class="do">## For storing selected pMEM eigenfunctions.</span></span>
<span id="cb18-4"><a href="#cb18-4" tabindex="-1"></a>lm <span class="ot">&lt;-</span> <span class="fu">list</span>()        <span class="do">## For storing the linear models.</span></span>
<span id="cb18-5"><a href="#cb18-5" tabindex="-1"></a>prd <span class="ot">&lt;-</span> <span class="fu">list</span>()       <span class="do">## For storing the predictions.</span></span></code></pre></div>
<p>To make predictions in a spatially-explicit manner, we first need to
figure out which distance weighting function (DWF) to use and what
parameter values to use with it. That decision can be carried out in
many ways, one of which consists in performing a global search using the
previously-defined objective function (<code>objf</code>). For this
example, the global search is itself carried out using the simulated
annealing implemented in <strong>R</strong> package
<strong>stat</strong>. Since we have to repeat the same analyses three
times for the different parr habitat descriptors, we defined a function
performing the required calculations as follows:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" tabindex="-1"></a>estimateSEF <span class="ot">&lt;-</span> <span class="cf">function</span>(x, xx, y, yy, lower, upper) {</span>
<span id="cb19-2"><a href="#cb19-2" tabindex="-1"></a>  </span>
<span id="cb19-3"><a href="#cb19-3" tabindex="-1"></a>  res <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="at">optim =</span> <span class="fu">list</span>())  <span class="do">## A list to contain the results.</span></span>
<span id="cb19-4"><a href="#cb19-4" tabindex="-1"></a>  </span>
<span id="cb19-5"><a href="#cb19-5" tabindex="-1"></a>  <span class="do">## This loop tries the seven DWF one by one, estimating &#39;dmax&#39; (and, when</span></span>
<span id="cb19-6"><a href="#cb19-6" tabindex="-1"></a>  <span class="do">## necessary, &#39;shape&#39;) using simulated annealing.</span></span>
<span id="cb19-7"><a href="#cb19-7" tabindex="-1"></a>  <span class="cf">for</span>(fun <span class="cf">in</span> <span class="fu">c</span>(<span class="st">&quot;linear&quot;</span>,<span class="st">&quot;power&quot;</span>,<span class="st">&quot;hyperbolic&quot;</span>,<span class="st">&quot;spherical&quot;</span>,<span class="st">&quot;exponential&quot;</span>,</span>
<span id="cb19-8"><a href="#cb19-8" tabindex="-1"></a>               <span class="st">&quot;Gaussian&quot;</span>,<span class="st">&quot;hole_effect&quot;</span>)) {</span>
<span id="cb19-9"><a href="#cb19-9" tabindex="-1"></a>    <span class="fu">optim</span>(</span>
<span id="cb19-10"><a href="#cb19-10" tabindex="-1"></a>      <span class="at">par =</span> <span class="fu">c</span>(<span class="dv">0</span>,<span class="cf">if</span>(fun <span class="sc">%in%</span> <span class="fu">c</span>(<span class="st">&quot;power&quot;</span>,<span class="st">&quot;hyperbolic&quot;</span>)) <span class="dv">0</span>), <span class="at">fn =</span> objf,</span>
<span id="cb19-11"><a href="#cb19-11" tabindex="-1"></a>      <span class="at">method =</span> <span class="st">&quot;SANN&quot;</span>, <span class="at">m =</span> <span class="fu">genDistMetric</span>(), <span class="at">fun =</span> fun,</span>
<span id="cb19-12"><a href="#cb19-12" tabindex="-1"></a>      <span class="at">x =</span> x, <span class="at">xx =</span> xx, <span class="at">y =</span> y, <span class="at">yy =</span> yy,</span>
<span id="cb19-13"><a href="#cb19-13" tabindex="-1"></a>      <span class="at">lb =</span> <span class="fu">c</span>(lower[<span class="dv">1</span>],<span class="cf">if</span>(fun <span class="sc">%in%</span> <span class="fu">c</span>(<span class="st">&quot;power&quot;</span>,<span class="st">&quot;hyperbolic&quot;</span>)) lower[<span class="dv">2</span>]),</span>
<span id="cb19-14"><a href="#cb19-14" tabindex="-1"></a>      <span class="at">ub =</span> <span class="fu">c</span>(upper[<span class="dv">1</span>],<span class="cf">if</span>(fun <span class="sc">%in%</span> <span class="fu">c</span>(<span class="st">&quot;power&quot;</span>,<span class="st">&quot;hyperbolic&quot;</span>)) upper[<span class="dv">2</span>])</span>
<span id="cb19-15"><a href="#cb19-15" tabindex="-1"></a>      </span>
<span id="cb19-16"><a href="#cb19-16" tabindex="-1"></a>    ) <span class="ot">-&gt;</span> res<span class="sc">$</span>optim[[fun]]</span>
<span id="cb19-17"><a href="#cb19-17" tabindex="-1"></a>  }</span>
<span id="cb19-18"><a href="#cb19-18" tabindex="-1"></a>  </span>
<span id="cb19-19"><a href="#cb19-19" tabindex="-1"></a>  <span class="do">## Extract the minimum values from the list of optimization:</span></span>
<span id="cb19-20"><a href="#cb19-20" tabindex="-1"></a>  <span class="fu">unlist</span>(</span>
<span id="cb19-21"><a href="#cb19-21" tabindex="-1"></a>    <span class="fu">lapply</span>(</span>
<span id="cb19-22"><a href="#cb19-22" tabindex="-1"></a>      res<span class="sc">$</span>optim,</span>
<span id="cb19-23"><a href="#cb19-23" tabindex="-1"></a>      <span class="cf">function</span>(x) x<span class="sc">$</span>value</span>
<span id="cb19-24"><a href="#cb19-24" tabindex="-1"></a>    )</span>
<span id="cb19-25"><a href="#cb19-25" tabindex="-1"></a>  ) <span class="ot">-&gt;</span> res<span class="sc">$</span>bestval</span>
<span id="cb19-26"><a href="#cb19-26" tabindex="-1"></a>  </span>
<span id="cb19-27"><a href="#cb19-27" tabindex="-1"></a>  <span class="do">## Find which DWF had the minimum objective criterion value:</span></span>
<span id="cb19-28"><a href="#cb19-28" tabindex="-1"></a>  <span class="fu">names</span>(</span>
<span id="cb19-29"><a href="#cb19-29" tabindex="-1"></a>    <span class="fu">which.min</span>(</span>
<span id="cb19-30"><a href="#cb19-30" tabindex="-1"></a>      res<span class="sc">$</span>bestval</span>
<span id="cb19-31"><a href="#cb19-31" tabindex="-1"></a>    )</span>
<span id="cb19-32"><a href="#cb19-32" tabindex="-1"></a>  ) <span class="ot">-&gt;</span> res<span class="sc">$</span>fun</span>
<span id="cb19-33"><a href="#cb19-33" tabindex="-1"></a>  </span>
<span id="cb19-34"><a href="#cb19-34" tabindex="-1"></a>  <span class="do">## Back-transform the parameter values:</span></span>
<span id="cb19-35"><a href="#cb19-35" tabindex="-1"></a>  res <span class="sc">%&gt;%</span></span>
<span id="cb19-36"><a href="#cb19-36" tabindex="-1"></a>    {.<span class="sc">$</span>optim[[.<span class="sc">$</span>fun]]<span class="sc">$</span>par} <span class="sc">%&gt;%</span></span>
<span id="cb19-37"><a href="#cb19-37" tabindex="-1"></a>    {(upper <span class="sc">-</span> lower) <span class="sc">*</span> (<span class="dv">1</span> <span class="sc">+</span> <span class="fu">exp</span>(<span class="sc">-</span>.))<span class="sc">^</span>(<span class="sc">-</span><span class="dv">1</span>) <span class="sc">+</span> lower} <span class="ot">-&gt;</span> res<span class="sc">$</span>par</span>
<span id="cb19-38"><a href="#cb19-38" tabindex="-1"></a>  </span>
<span id="cb19-39"><a href="#cb19-39" tabindex="-1"></a>  <span class="do">## Calculate the SEF using the optimized DWF parameters:</span></span>
<span id="cb19-40"><a href="#cb19-40" tabindex="-1"></a>  res <span class="sc">%&gt;%</span></span>
<span id="cb19-41"><a href="#cb19-41" tabindex="-1"></a>    {<span class="fu">genSEF</span>(</span>
<span id="cb19-42"><a href="#cb19-42" tabindex="-1"></a>      <span class="at">x =</span> x,</span>
<span id="cb19-43"><a href="#cb19-43" tabindex="-1"></a>      <span class="at">m =</span> <span class="fu">genDistMetric</span>(),</span>
<span id="cb19-44"><a href="#cb19-44" tabindex="-1"></a>      <span class="at">f =</span> <span class="fu">genDWF</span>(.<span class="sc">$</span>fun, .<span class="sc">$</span>par[<span class="dv">1</span><span class="dt">L</span>], <span class="cf">if</span>(<span class="fu">length</span>(.<span class="sc">$</span>par) <span class="sc">&gt;</span> <span class="dv">1</span>) .<span class="sc">$</span>par[<span class="dv">1</span><span class="dt">L</span>])</span>
<span id="cb19-45"><a href="#cb19-45" tabindex="-1"></a>    )} <span class="ot">-&gt;</span> res<span class="sc">$</span>sef</span>
<span id="cb19-46"><a href="#cb19-46" tabindex="-1"></a>  </span>
<span id="cb19-47"><a href="#cb19-47" tabindex="-1"></a>  <span class="do">## Return the result list:</span></span>
<span id="cb19-48"><a href="#cb19-48" tabindex="-1"></a>  res</span>
<span id="cb19-49"><a href="#cb19-49" tabindex="-1"></a>}</span></code></pre></div>
<div id="channel-depth" class="section level3">
<h3>Channel depth</h3>
<p>The channel depth is an important descriptor of juvenile Atlantic
salmon (parr) habitat. For instance, these fish use riffles to feed on
drifting preys; it is while feeding that they are the most readily
observable by snorkelers. They may also use pools as a refuge from
predators or, perhaps, head for riffles with a close by pool in order to
benefit from favourable hydrological conditions as well as readily
available refuge. In salmon rivers, pools and riffles alternate
successively, in a more or less regular manners; it might thus by
possible to model part of the variation in channel depth using pMEM.</p>
<p>Let us estimate the optimal SEF for modelling channel depth as
follows:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" tabindex="-1"></a><span class="fu">estimateSEF</span>(</span>
<span id="cb20-2"><a href="#cb20-2" tabindex="-1"></a>  <span class="at">x =</span> salmon<span class="sc">$</span>Position[train],</span>
<span id="cb20-3"><a href="#cb20-3" tabindex="-1"></a>  <span class="at">xx =</span> salmon<span class="sc">$</span>Position[test],</span>
<span id="cb20-4"><a href="#cb20-4" tabindex="-1"></a>  <span class="at">y =</span> salmon[[<span class="st">&quot;Depth&quot;</span>]][train],</span>
<span id="cb20-5"><a href="#cb20-5" tabindex="-1"></a>  <span class="at">yy =</span> salmon[[<span class="st">&quot;Depth&quot;</span>]][test],</span>
<span id="cb20-6"><a href="#cb20-6" tabindex="-1"></a>  <span class="at">lower =</span> <span class="fu">c</span>(<span class="dv">20</span>,<span class="fl">0.25</span>),</span>
<span id="cb20-7"><a href="#cb20-7" tabindex="-1"></a>  <span class="at">upper =</span> <span class="fu">c</span>(<span class="dv">1000</span>,<span class="fl">1.75</span>)</span>
<span id="cb20-8"><a href="#cb20-8" tabindex="-1"></a>) <span class="ot">-&gt;</span> sefTrain[[<span class="st">&quot;Depth&quot;</span>]]</span></code></pre></div>
<p>The best DWF found has been <em>linear</em>, with a <span class="math inline">\(d_{max}\)</span> of <span class="math inline">\(65\,\mathrm{m}\)</span>. The <code>minMSE</code>
model estimated for the channel depth using these parameters is obtained
as follows:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1" tabindex="-1"></a><span class="do">## Calculate the channel depth model:</span></span>
<span id="cb21-2"><a href="#cb21-2" tabindex="-1"></a>sefTrain[[<span class="st">&quot;Depth&quot;</span>]]<span class="sc">$</span>sef <span class="sc">%&gt;%</span></span>
<span id="cb21-3"><a href="#cb21-3" tabindex="-1"></a>  {<span class="fu">getMinMSE</span>(</span>
<span id="cb21-4"><a href="#cb21-4" tabindex="-1"></a>    <span class="at">U =</span> <span class="fu">as.matrix</span>(.),</span>
<span id="cb21-5"><a href="#cb21-5" tabindex="-1"></a>    <span class="at">y =</span> salmon[[<span class="st">&quot;Depth&quot;</span>]][train],</span>
<span id="cb21-6"><a href="#cb21-6" tabindex="-1"></a>    <span class="at">Up =</span> <span class="fu">predict</span>(., salmon<span class="sc">$</span>Position[test]),</span>
<span id="cb21-7"><a href="#cb21-7" tabindex="-1"></a>    <span class="at">yy =</span> salmon[[<span class="st">&quot;Depth&quot;</span>]][test]</span>
<span id="cb21-8"><a href="#cb21-8" tabindex="-1"></a>  )} <span class="ot">-&gt;</span> mseRes[[<span class="st">&quot;Depth&quot;</span>]]</span>
<span id="cb21-9"><a href="#cb21-9" tabindex="-1"></a></span>
<span id="cb21-10"><a href="#cb21-10" tabindex="-1"></a><span class="do">## Extract the selected SEF:</span></span>
<span id="cb21-11"><a href="#cb21-11" tabindex="-1"></a>mseRes[[<span class="st">&quot;Depth&quot;</span>]] <span class="sc">%&gt;%</span> {<span class="fu">sort</span>(.<span class="sc">$</span>ord[<span class="dv">1</span><span class="sc">:</span>.<span class="sc">$</span>wh])} <span class="ot">-&gt;</span> sel[[<span class="st">&quot;Depth&quot;</span>]]</span></code></pre></div>
<p>which has a coefficient of prediction of 0.7003. Now, we can
calculate a linear (regression) model from the selected spatial
eigenfunctions:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" tabindex="-1"></a><span class="do">## Calculate a linear model from the selected SEF:</span></span>
<span id="cb22-2"><a href="#cb22-2" tabindex="-1"></a><span class="fu">lm</span>(</span>
<span id="cb22-3"><a href="#cb22-3" tabindex="-1"></a>  <span class="at">formula =</span> y<span class="sc">~</span>.,</span>
<span id="cb22-4"><a href="#cb22-4" tabindex="-1"></a>  <span class="at">data =</span> <span class="fu">cbind</span>(</span>
<span id="cb22-5"><a href="#cb22-5" tabindex="-1"></a>    <span class="at">y =</span> salmon[[<span class="st">&quot;Depth&quot;</span>]][train],</span>
<span id="cb22-6"><a href="#cb22-6" tabindex="-1"></a>    <span class="fu">as.data.frame</span>(sefTrain[[<span class="st">&quot;Depth&quot;</span>]]<span class="sc">$</span>sef, <span class="at">wh=</span>sel[[<span class="st">&quot;Depth&quot;</span>]])</span>
<span id="cb22-7"><a href="#cb22-7" tabindex="-1"></a>  )</span>
<span id="cb22-8"><a href="#cb22-8" tabindex="-1"></a>) <span class="ot">-&gt;</span> lm[[<span class="st">&quot;Depth&quot;</span>]]</span>
<span id="cb22-9"><a href="#cb22-9" tabindex="-1"></a></span>
<span id="cb22-10"><a href="#cb22-10" tabindex="-1"></a><span class="do">## Calculate the predictions:</span></span>
<span id="cb22-11"><a href="#cb22-11" tabindex="-1"></a><span class="fu">predict</span>(</span>
<span id="cb22-12"><a href="#cb22-12" tabindex="-1"></a>  lm[[<span class="st">&quot;Depth&quot;</span>]],</span>
<span id="cb22-13"><a href="#cb22-13" tabindex="-1"></a>  <span class="at">newdata =</span> <span class="fu">as.data.frame</span>(</span>
<span id="cb22-14"><a href="#cb22-14" tabindex="-1"></a>    <span class="fu">predict</span>(</span>
<span id="cb22-15"><a href="#cb22-15" tabindex="-1"></a>      <span class="at">object =</span> sefTrain[[<span class="st">&quot;Depth&quot;</span>]]<span class="sc">$</span>sef,</span>
<span id="cb22-16"><a href="#cb22-16" tabindex="-1"></a>      <span class="at">newdata =</span> xx,</span>
<span id="cb22-17"><a href="#cb22-17" tabindex="-1"></a>      <span class="at">wh =</span> sel[[<span class="st">&quot;Depth&quot;</span>]]</span>
<span id="cb22-18"><a href="#cb22-18" tabindex="-1"></a>    )</span>
<span id="cb22-19"><a href="#cb22-19" tabindex="-1"></a>  )</span>
<span id="cb22-20"><a href="#cb22-20" tabindex="-1"></a>) <span class="ot">-&gt;</span> prd[[<span class="st">&quot;Depth&quot;</span>]]</span></code></pre></div>
<p>The predictions of the channel depth can be displayed as follows:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1" tabindex="-1"></a><span class="fu">plot</span>(<span class="at">x=</span>xx, <span class="at">y=</span>prd[[<span class="st">&quot;Depth&quot;</span>]], <span class="at">type=</span><span class="st">&quot;l&quot;</span>,</span>
<span id="cb23-2"><a href="#cb23-2" tabindex="-1"></a>     <span class="at">ylim=</span><span class="fu">range</span>(salmon[[<span class="st">&quot;Depth&quot;</span>]], prd[[<span class="st">&quot;Depth&quot;</span>]]), <span class="at">las=</span><span class="dv">1</span>,</span>
<span id="cb23-3"><a href="#cb23-3" tabindex="-1"></a>     <span class="at">ylab=</span><span class="st">&quot;Channel depth (m)&quot;</span>, <span class="at">xlab=</span><span class="st">&quot;Location along the transect (m)&quot;</span>)</span>
<span id="cb23-4"><a href="#cb23-4" tabindex="-1"></a><span class="fu">points</span>(<span class="at">x =</span> salmon<span class="sc">$</span>Position[train], <span class="at">y =</span> salmon[[<span class="st">&quot;Depth&quot;</span>]][train], <span class="at">pch=</span><span class="dv">21</span>,</span>
<span id="cb23-5"><a href="#cb23-5" tabindex="-1"></a>       <span class="at">bg=</span><span class="st">&quot;black&quot;</span>)</span>
<span id="cb23-6"><a href="#cb23-6" tabindex="-1"></a><span class="fu">points</span>(<span class="at">x =</span> salmon<span class="sc">$</span>Position[test], <span class="at">y =</span> salmon[[<span class="st">&quot;Depth&quot;</span>]][test], <span class="at">pch=</span><span class="dv">21</span>, <span class="at">bg=</span><span class="st">&quot;red&quot;</span>)</span></code></pre></div>
<p><img role="img" src="data:image/png;base64,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" /><!-- --></p>
<p>Fig. 2. Spatially-explicit predictions of channel depth (black solid
line) with observations used training (black markers) and testing (red
markers) the model.</p>
<hr />
</div>
<div id="current-velocity" class="section level3">
<h3>Current velocity</h3>
<p>The second parr habitat descriptor is current velocity. Parrs fed on
drifting prey animals (mostly insects) and thus rely on water current to
bring about these preys. Whereas a fast current will bring preys at a
high rate, is also entails less time reach for them and having to work
harder in order to do so. As for channel depth, sections of slow and
fast current alternate in a more or less consistent manner which might,
to some extent, be modelled in a spatially-explicit manner. Current
velocity is modelled as for the channel depth as follows:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1" tabindex="-1"></a><span class="do">## Estimate the most adequate predictive Moran&#39;s eigenvector map:</span></span>
<span id="cb24-2"><a href="#cb24-2" tabindex="-1"></a><span class="fu">estimateSEF</span>(</span>
<span id="cb24-3"><a href="#cb24-3" tabindex="-1"></a>  <span class="at">x =</span> salmon<span class="sc">$</span>Position[train],</span>
<span id="cb24-4"><a href="#cb24-4" tabindex="-1"></a>  <span class="at">xx =</span> salmon<span class="sc">$</span>Position[test],</span>
<span id="cb24-5"><a href="#cb24-5" tabindex="-1"></a>  <span class="at">y =</span> salmon[[<span class="st">&quot;Velocity&quot;</span>]][train],</span>
<span id="cb24-6"><a href="#cb24-6" tabindex="-1"></a>  <span class="at">yy =</span> salmon[[<span class="st">&quot;Velocity&quot;</span>]][test],</span>
<span id="cb24-7"><a href="#cb24-7" tabindex="-1"></a>  <span class="at">lower =</span> <span class="fu">c</span>(<span class="dv">20</span>,<span class="fl">0.25</span>),</span>
<span id="cb24-8"><a href="#cb24-8" tabindex="-1"></a>  <span class="at">upper =</span> <span class="fu">c</span>(<span class="dv">1000</span>,<span class="fl">1.75</span>)</span>
<span id="cb24-9"><a href="#cb24-9" tabindex="-1"></a>) <span class="ot">-&gt;</span> sefTrain[[<span class="st">&quot;Velocity&quot;</span>]]</span></code></pre></div>
<div class="sourceCode" id="cb25"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1" tabindex="-1"></a><span class="do">## Calculate the current velocity model:</span></span>
<span id="cb25-2"><a href="#cb25-2" tabindex="-1"></a>sefTrain[[<span class="st">&quot;Velocity&quot;</span>]]<span class="sc">$</span>sef <span class="sc">%&gt;%</span></span>
<span id="cb25-3"><a href="#cb25-3" tabindex="-1"></a>  {<span class="fu">getMinMSE</span>(</span>
<span id="cb25-4"><a href="#cb25-4" tabindex="-1"></a>    <span class="at">U =</span> <span class="fu">as.matrix</span>(.),</span>
<span id="cb25-5"><a href="#cb25-5" tabindex="-1"></a>    <span class="at">y =</span> salmon[[<span class="st">&quot;Velocity&quot;</span>]][train],</span>
<span id="cb25-6"><a href="#cb25-6" tabindex="-1"></a>    <span class="at">Up =</span> <span class="fu">predict</span>(., salmon<span class="sc">$</span>Position[test]),</span>
<span id="cb25-7"><a href="#cb25-7" tabindex="-1"></a>    <span class="at">yy =</span> salmon[[<span class="st">&quot;Velocity&quot;</span>]][test]</span>
<span id="cb25-8"><a href="#cb25-8" tabindex="-1"></a>  )} <span class="ot">-&gt;</span> mseRes[[<span class="st">&quot;Velocity&quot;</span>]]</span>
<span id="cb25-9"><a href="#cb25-9" tabindex="-1"></a></span>
<span id="cb25-10"><a href="#cb25-10" tabindex="-1"></a><span class="do">## Extract the selected SEF:</span></span>
<span id="cb25-11"><a href="#cb25-11" tabindex="-1"></a>mseRes[[<span class="st">&quot;Velocity&quot;</span>]] <span class="sc">%&gt;%</span> {<span class="fu">sort</span>(.<span class="sc">$</span>ord[<span class="dv">1</span><span class="sc">:</span>.<span class="sc">$</span>wh])} <span class="ot">-&gt;</span> sel[[<span class="st">&quot;Velocity&quot;</span>]]</span>
<span id="cb25-12"><a href="#cb25-12" tabindex="-1"></a></span>
<span id="cb25-13"><a href="#cb25-13" tabindex="-1"></a><span class="do">## Calculate a linear model from the selected SEF:</span></span>
<span id="cb25-14"><a href="#cb25-14" tabindex="-1"></a><span class="fu">lm</span>(</span>
<span id="cb25-15"><a href="#cb25-15" tabindex="-1"></a>  <span class="at">formula =</span> y<span class="sc">~</span>.,</span>
<span id="cb25-16"><a href="#cb25-16" tabindex="-1"></a>  <span class="at">data =</span> <span class="fu">cbind</span>(</span>
<span id="cb25-17"><a href="#cb25-17" tabindex="-1"></a>    <span class="at">y =</span> salmon[[<span class="st">&quot;Velocity&quot;</span>]][train],</span>
<span id="cb25-18"><a href="#cb25-18" tabindex="-1"></a>    <span class="fu">as.data.frame</span>(sefTrain[[<span class="st">&quot;Velocity&quot;</span>]]<span class="sc">$</span>sef, <span class="at">wh=</span>sel[[<span class="st">&quot;Velocity&quot;</span>]])</span>
<span id="cb25-19"><a href="#cb25-19" tabindex="-1"></a>  )</span>
<span id="cb25-20"><a href="#cb25-20" tabindex="-1"></a>) <span class="ot">-&gt;</span> lm[[<span class="st">&quot;Velocity&quot;</span>]]</span>
<span id="cb25-21"><a href="#cb25-21" tabindex="-1"></a></span>
<span id="cb25-22"><a href="#cb25-22" tabindex="-1"></a><span class="do">## Calculate the predictions:</span></span>
<span id="cb25-23"><a href="#cb25-23" tabindex="-1"></a><span class="fu">predict</span>(</span>
<span id="cb25-24"><a href="#cb25-24" tabindex="-1"></a>  lm[[<span class="st">&quot;Velocity&quot;</span>]],</span>
<span id="cb25-25"><a href="#cb25-25" tabindex="-1"></a>  <span class="at">newdata =</span> <span class="fu">as.data.frame</span>(</span>
<span id="cb25-26"><a href="#cb25-26" tabindex="-1"></a>    <span class="fu">predict</span>(</span>
<span id="cb25-27"><a href="#cb25-27" tabindex="-1"></a>      <span class="at">object =</span> sefTrain[[<span class="st">&quot;Velocity&quot;</span>]]<span class="sc">$</span>sef,</span>
<span id="cb25-28"><a href="#cb25-28" tabindex="-1"></a>      <span class="at">newdata =</span> xx,</span>
<span id="cb25-29"><a href="#cb25-29" tabindex="-1"></a>      <span class="at">wh =</span> sel[[<span class="st">&quot;Velocity&quot;</span>]]</span>
<span id="cb25-30"><a href="#cb25-30" tabindex="-1"></a>    )</span>
<span id="cb25-31"><a href="#cb25-31" tabindex="-1"></a>  )</span>
<span id="cb25-32"><a href="#cb25-32" tabindex="-1"></a>) <span class="ot">-&gt;</span> prd[[<span class="st">&quot;Velocity&quot;</span>]]</span></code></pre></div>
<p>This time, the best DWF found has been <em>linear</em>, with a <span class="math inline">\(d_{max}\)</span> of <span class="math inline">\(742\,\mathrm{m}\)</span>, a coefficient of
predictions of 0.4914, and the predictions appear as follows:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb26-1"><a href="#cb26-1" tabindex="-1"></a><span class="fu">plot</span>(<span class="at">x=</span>xx, <span class="at">y=</span>prd[[<span class="st">&quot;Velocity&quot;</span>]], <span class="at">type=</span><span class="st">&quot;l&quot;</span>,</span>
<span id="cb26-2"><a href="#cb26-2" tabindex="-1"></a>     <span class="at">ylim=</span><span class="fu">range</span>(salmon[[<span class="st">&quot;Velocity&quot;</span>]], prd[[<span class="st">&quot;Velocity&quot;</span>]]), <span class="at">las=</span><span class="dv">1</span>,</span>
<span id="cb26-3"><a href="#cb26-3" tabindex="-1"></a>     <span class="at">ylab=</span><span class="st">&quot;Velocity (m/s)&quot;</span>, <span class="at">xlab=</span><span class="st">&quot;Location along the transect (m)&quot;</span>)</span>
<span id="cb26-4"><a href="#cb26-4" tabindex="-1"></a><span class="fu">points</span>(<span class="at">x =</span> salmon<span class="sc">$</span>Position[train], <span class="at">y =</span> salmon[[<span class="st">&quot;Velocity&quot;</span>]][train], <span class="at">pch=</span><span class="dv">21</span>,</span>
<span id="cb26-5"><a href="#cb26-5" tabindex="-1"></a>       <span class="at">bg=</span><span class="st">&quot;black&quot;</span>)</span>
<span id="cb26-6"><a href="#cb26-6" tabindex="-1"></a><span class="fu">points</span>(<span class="at">x =</span> salmon<span class="sc">$</span>Position[test], <span class="at">y =</span> salmon[[<span class="st">&quot;Velocity&quot;</span>]][test], <span class="at">pch=</span><span class="dv">21</span>,</span>
<span id="cb26-7"><a href="#cb26-7" tabindex="-1"></a>       <span class="at">bg=</span><span class="st">&quot;red&quot;</span>)</span></code></pre></div>
<p><img role="img" src="data:image/png;base64,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" /><!-- --></p>
<p>Fig. 3. Spatially-explicit predictions of current velocity (black
solid line) with observations used training (black markers) and testing
(red markers) the model.</p>
<hr />
</div>
<div id="substrate-grain-size" class="section level3">
<h3>Substrate grain size</h3>
<p>Atlantic salmon parr is bottom dwelling fish that use the
hydrodynamic conditions in the vicinity of the substrate in various
manner. While feeding, for instance, it typically choose a cobble
against which it lays its pectoral fins to help in holding a steady
position in the stream. Also, it uses zones of back-flow close to the
rough bottom surface in order to swim back to its ambush position.
Substrate composition may thus be a dependable descriptor of the parr
habitat. Substrate mean grain size is modelled as for the two previous
descriptors as follows:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb27-1"><a href="#cb27-1" tabindex="-1"></a><span class="do">## Estimate the most adequate predictive Moran&#39;s eigenvector map:</span></span>
<span id="cb27-2"><a href="#cb27-2" tabindex="-1"></a><span class="fu">estimateSEF</span>(</span>
<span id="cb27-3"><a href="#cb27-3" tabindex="-1"></a>  <span class="at">x =</span> salmon<span class="sc">$</span>Position[train],</span>
<span id="cb27-4"><a href="#cb27-4" tabindex="-1"></a>  <span class="at">xx =</span> salmon<span class="sc">$</span>Position[test],</span>
<span id="cb27-5"><a href="#cb27-5" tabindex="-1"></a>  <span class="at">y =</span> salmon[[<span class="st">&quot;Substrate&quot;</span>]][train],</span>
<span id="cb27-6"><a href="#cb27-6" tabindex="-1"></a>  <span class="at">yy =</span> salmon[[<span class="st">&quot;Substrate&quot;</span>]][test],</span>
<span id="cb27-7"><a href="#cb27-7" tabindex="-1"></a>  <span class="at">lower =</span> <span class="fu">c</span>(<span class="dv">20</span>,<span class="fl">0.25</span>),</span>
<span id="cb27-8"><a href="#cb27-8" tabindex="-1"></a>  <span class="at">upper =</span> <span class="fu">c</span>(<span class="dv">1000</span>,<span class="fl">1.75</span>)</span>
<span id="cb27-9"><a href="#cb27-9" tabindex="-1"></a>) <span class="ot">-&gt;</span> sefTrain[[<span class="st">&quot;Substrate&quot;</span>]]</span></code></pre></div>
<div class="sourceCode" id="cb28"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb28-1"><a href="#cb28-1" tabindex="-1"></a><span class="do">## Calculate the mean substrate grain size model:</span></span>
<span id="cb28-2"><a href="#cb28-2" tabindex="-1"></a>sefTrain[[<span class="st">&quot;Substrate&quot;</span>]]<span class="sc">$</span>sef <span class="sc">%&gt;%</span></span>
<span id="cb28-3"><a href="#cb28-3" tabindex="-1"></a>  {<span class="fu">getMinMSE</span>(</span>
<span id="cb28-4"><a href="#cb28-4" tabindex="-1"></a>    <span class="at">U =</span> <span class="fu">as.matrix</span>(.),</span>
<span id="cb28-5"><a href="#cb28-5" tabindex="-1"></a>    <span class="at">y =</span> salmon[[<span class="st">&quot;Substrate&quot;</span>]][train],</span>
<span id="cb28-6"><a href="#cb28-6" tabindex="-1"></a>    <span class="at">Up =</span> <span class="fu">predict</span>(., salmon<span class="sc">$</span>Position[test]),</span>
<span id="cb28-7"><a href="#cb28-7" tabindex="-1"></a>    <span class="at">yy =</span> salmon[[<span class="st">&quot;Substrate&quot;</span>]][test]</span>
<span id="cb28-8"><a href="#cb28-8" tabindex="-1"></a>  )} <span class="ot">-&gt;</span> mseRes[[<span class="st">&quot;Substrate&quot;</span>]]</span>
<span id="cb28-9"><a href="#cb28-9" tabindex="-1"></a></span>
<span id="cb28-10"><a href="#cb28-10" tabindex="-1"></a><span class="do">## Extract the selected SEF:</span></span>
<span id="cb28-11"><a href="#cb28-11" tabindex="-1"></a>mseRes[[<span class="st">&quot;Substrate&quot;</span>]] <span class="sc">%&gt;%</span> {<span class="fu">sort</span>(.<span class="sc">$</span>ord[<span class="dv">1</span><span class="sc">:</span>.<span class="sc">$</span>wh])} <span class="ot">-&gt;</span> sel[[<span class="st">&quot;Substrate&quot;</span>]]</span>
<span id="cb28-12"><a href="#cb28-12" tabindex="-1"></a></span>
<span id="cb28-13"><a href="#cb28-13" tabindex="-1"></a><span class="do">## Calculate a linear model from the selected SEF:</span></span>
<span id="cb28-14"><a href="#cb28-14" tabindex="-1"></a><span class="fu">lm</span>(</span>
<span id="cb28-15"><a href="#cb28-15" tabindex="-1"></a>  <span class="at">formula =</span> y<span class="sc">~</span>.,</span>
<span id="cb28-16"><a href="#cb28-16" tabindex="-1"></a>  <span class="at">data =</span> <span class="fu">cbind</span>(</span>
<span id="cb28-17"><a href="#cb28-17" tabindex="-1"></a>    <span class="at">y =</span> salmon[[<span class="st">&quot;Substrate&quot;</span>]][train],</span>
<span id="cb28-18"><a href="#cb28-18" tabindex="-1"></a>    <span class="fu">as.data.frame</span>(sefTrain[[<span class="st">&quot;Substrate&quot;</span>]]<span class="sc">$</span>sef, <span class="at">wh=</span>sel[[<span class="st">&quot;Substrate&quot;</span>]])</span>
<span id="cb28-19"><a href="#cb28-19" tabindex="-1"></a>  )</span>
<span id="cb28-20"><a href="#cb28-20" tabindex="-1"></a>) <span class="ot">-&gt;</span> lm[[<span class="st">&quot;Substrate&quot;</span>]]</span>
<span id="cb28-21"><a href="#cb28-21" tabindex="-1"></a></span>
<span id="cb28-22"><a href="#cb28-22" tabindex="-1"></a><span class="do">## Calculate the predictions:</span></span>
<span id="cb28-23"><a href="#cb28-23" tabindex="-1"></a><span class="fu">predict</span>(</span>
<span id="cb28-24"><a href="#cb28-24" tabindex="-1"></a>  lm[[<span class="st">&quot;Substrate&quot;</span>]],</span>
<span id="cb28-25"><a href="#cb28-25" tabindex="-1"></a>  <span class="at">newdata =</span> <span class="fu">as.data.frame</span>(</span>
<span id="cb28-26"><a href="#cb28-26" tabindex="-1"></a>    <span class="fu">predict</span>(</span>
<span id="cb28-27"><a href="#cb28-27" tabindex="-1"></a>      <span class="at">object =</span> sefTrain[[<span class="st">&quot;Substrate&quot;</span>]]<span class="sc">$</span>sef,</span>
<span id="cb28-28"><a href="#cb28-28" tabindex="-1"></a>      <span class="at">newdata =</span> xx,</span>
<span id="cb28-29"><a href="#cb28-29" tabindex="-1"></a>      <span class="at">wh =</span> sel[[<span class="st">&quot;Substrate&quot;</span>]]</span>
<span id="cb28-30"><a href="#cb28-30" tabindex="-1"></a>    )</span>
<span id="cb28-31"><a href="#cb28-31" tabindex="-1"></a>  )</span>
<span id="cb28-32"><a href="#cb28-32" tabindex="-1"></a>) <span class="ot">-&gt;</span> prd[[<span class="st">&quot;Substrate&quot;</span>]]</span></code></pre></div>
<p>For mean substrate grain size, the best DWF found has been
<em>power</em>, with a <span class="math inline">\(d_{max}\)</span> of
<span class="math inline">\(881\,\mathrm{m}\)</span>, a <span class="math inline">\(\alpha\)</span> of <span class="math inline">\(1.67\)</span> coefficient of predictions of
0.5726, and the predictions appear as follows:</p>
<p><img role="img" src="data:image/png;base64,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" /><!-- --></p>
<p>Fig. 4. Spatially-explicit predictions of mean substrate grain size
(black solid line) with observations used training (black markers) and
testing (red markers) the model.</p>
<hr />
</div>
</div>
<div id="atlantic-salmon-parr-abundance" class="section level2">
<h2>Atlantic salmon parr abundance</h2>
<p>The Atlantic parr abundances are count data, suggesting it is the
result of a Poisson process. A Poisson GLM is a straightforward way to
model a Poisson process. Here, we will take this situation as an
opportunity to exemplify another way whereby pMEM could be used for
modelling, this time using an “elasticnet”-regularized generalized
linear model. For that purpose, we need another objective function using
function <code>glmnet</code> for model estimation, and having arguments
<code>w</code> and <code>ww</code> to to pass auxiliary descriptors
(training and testing sets, respectively), to be used alongside the SEF
in modelling parr, abundance as follows:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb29-1"><a href="#cb29-1" tabindex="-1"></a>objf2 <span class="ot">&lt;-</span> <span class="cf">function</span>(par, m, fun, x, xx, y, yy, w, ww, lb, ub) {</span>
<span id="cb29-2"><a href="#cb29-2" tabindex="-1"></a>  par <span class="ot">&lt;-</span> (ub <span class="sc">-</span> lb) <span class="sc">*</span> (<span class="dv">1</span> <span class="sc">+</span> <span class="fu">exp</span>(<span class="sc">-</span>par))<span class="sc">^</span>(<span class="sc">-</span><span class="dv">1</span>) <span class="sc">+</span> lb</span>
<span id="cb29-3"><a href="#cb29-3" tabindex="-1"></a>  <span class="cf">if</span>(fun <span class="sc">%in%</span> <span class="fu">c</span>(<span class="st">&quot;power&quot;</span>,<span class="st">&quot;hyperbolic&quot;</span>)) {</span>
<span id="cb29-4"><a href="#cb29-4" tabindex="-1"></a>    sef <span class="ot">&lt;-</span> <span class="fu">genSEF</span>(x, m, <span class="fu">genDWF</span>(fun, <span class="at">range =</span> par[<span class="dv">3</span><span class="dt">L</span>], <span class="at">shape =</span> par[<span class="dv">4</span><span class="dt">L</span>]))</span>
<span id="cb29-5"><a href="#cb29-5" tabindex="-1"></a>  } <span class="cf">else</span></span>
<span id="cb29-6"><a href="#cb29-6" tabindex="-1"></a>    sef <span class="ot">&lt;-</span> <span class="fu">genSEF</span>(x, m, <span class="fu">genDWF</span>(fun, <span class="at">range =</span> par[<span class="dv">3</span><span class="dt">L</span>]))</span>
<span id="cb29-7"><a href="#cb29-7" tabindex="-1"></a>  glm1 <span class="ot">&lt;-</span> <span class="fu">glmnet</span>(<span class="at">x =</span> <span class="fu">cbind</span>(w, <span class="fu">as.matrix</span>(sef)), <span class="at">y =</span> y, <span class="at">family =</span> <span class="st">&quot;poisson&quot;</span>,</span>
<span id="cb29-8"><a href="#cb29-8" tabindex="-1"></a>                 <span class="at">alpha =</span> par[<span class="dv">1</span><span class="dt">L</span>], <span class="at">lambda =</span> par[<span class="dv">2</span><span class="dt">L</span>])</span>
<span id="cb29-9"><a href="#cb29-9" tabindex="-1"></a>  pp <span class="ot">&lt;-</span> <span class="fu">predict</span>(glm1, <span class="at">newx =</span> <span class="fu">cbind</span>(ww, <span class="fu">predict</span>(sef, xx)), <span class="at">type=</span><span class="st">&quot;response&quot;</span>)</span>
<span id="cb29-10"><a href="#cb29-10" tabindex="-1"></a>  <span class="sc">-</span><span class="dv">2</span><span class="sc">*</span><span class="fu">sum</span>(<span class="fu">dpois</span>(yy, pp, <span class="at">log =</span> <span class="cn">TRUE</span>))</span>
<span id="cb29-11"><a href="#cb29-11" tabindex="-1"></a>}</span></code></pre></div>
<p>That objective function has three or four parameters (depending on
the presence of the shape parameter), rather than 1 or 2 for
<code>objf</code>:</p>
<ol style="list-style-type: decimal">
<li><p>the <span class="math inline">\(\alpha\)</span> parameter of the
elastic net regression that define the amount of <span class="math inline">\(L_1\)</span> with respect to <span class="math inline">\(L_2\)</span> norm used for
regularization,</p></li>
<li><p>the <span class="math inline">\(\lambda\)</span> parameter, which
is the overall amount of regularization,</p></li>
<li><p>the <span class="math inline">\(d_{max}\)</span> parameter of the
DWF, and</p></li>
<li><p>the shape parameter of the DWF, when necessary.</p></li>
</ol>
<p>The value returned is the out of the sample deviance value rather
than the out of the sample mean square error that was returned by the
first objective function.</p>
<p>The auxiliary descriptors are the channel depth, current velocity,
and mean substrate grain size. There may be non-linear relationships
between these descriptors and parr abndance, because parr may prefer
sites with intermediate values of these descriptors over extremes. To
allow the parr abundance model the opportunity to exploit that
possibility, we calculated orthogonal polynomials from the training data
using <strong>R</strong> function <code>poly</code> as follows:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb30-1"><a href="#cb30-1" tabindex="-1"></a><span class="do">## Implement a list of orthogonal polynomial objects:</span></span>
<span id="cb30-2"><a href="#cb30-2" tabindex="-1"></a>plist <span class="ot">&lt;-</span> <span class="fu">list</span>()</span>
<span id="cb30-3"><a href="#cb30-3" tabindex="-1"></a>plist[[<span class="st">&quot;Depth&quot;</span>]] <span class="ot">&lt;-</span> <span class="fu">poly</span>(salmon[train,<span class="st">&quot;Depth&quot;</span>],<span class="dv">2</span>)</span>
<span id="cb30-4"><a href="#cb30-4" tabindex="-1"></a>plist[[<span class="st">&quot;Velocity&quot;</span>]] <span class="ot">&lt;-</span> <span class="fu">poly</span>(salmon[train,<span class="st">&quot;Velocity&quot;</span>],<span class="dv">2</span>)</span>
<span id="cb30-5"><a href="#cb30-5" tabindex="-1"></a>plist[[<span class="st">&quot;Substrate&quot;</span>]] <span class="ot">&lt;-</span> <span class="fu">poly</span>(salmon[train,<span class="st">&quot;Substrate&quot;</span>],<span class="dv">2</span>)</span>
<span id="cb30-6"><a href="#cb30-6" tabindex="-1"></a></span>
<span id="cb30-7"><a href="#cb30-7" tabindex="-1"></a><span class="do">## The matrix of auxiliary descriptor for the training set:</span></span>
<span id="cb30-8"><a href="#cb30-8" tabindex="-1"></a><span class="fu">cbind</span>(</span>
<span id="cb30-9"><a href="#cb30-9" tabindex="-1"></a>  <span class="fu">as.matrix</span>(plist[[<span class="st">&quot;Depth&quot;</span>]]),</span>
<span id="cb30-10"><a href="#cb30-10" tabindex="-1"></a>  <span class="fu">as.matrix</span>(plist[[<span class="st">&quot;Velocity&quot;</span>]]),</span>
<span id="cb30-11"><a href="#cb30-11" tabindex="-1"></a>  <span class="fu">as.matrix</span>(plist[[<span class="st">&quot;Substrate&quot;</span>]])</span>
<span id="cb30-12"><a href="#cb30-12" tabindex="-1"></a>) <span class="ot">-&gt;</span> w</span>
<span id="cb30-13"><a href="#cb30-13" tabindex="-1"></a></span>
<span id="cb30-14"><a href="#cb30-14" tabindex="-1"></a><span class="do">## Generate suitable column names:</span></span>
<span id="cb30-15"><a href="#cb30-15" tabindex="-1"></a><span class="fu">c</span>(<span class="st">&quot;Depth^1&quot;</span>,<span class="st">&quot;Depth^2&quot;</span>,</span>
<span id="cb30-16"><a href="#cb30-16" tabindex="-1"></a>  <span class="st">&quot;Velocity^1&quot;</span>,<span class="st">&quot;Velocity^2&quot;</span>,</span>
<span id="cb30-17"><a href="#cb30-17" tabindex="-1"></a>  <span class="st">&quot;Substrate^1&quot;</span>,<span class="st">&quot;Substrate^2&quot;</span>) <span class="ot">-&gt;</span> <span class="fu">colnames</span>(w)</span>
<span id="cb30-18"><a href="#cb30-18" tabindex="-1"></a></span>
<span id="cb30-19"><a href="#cb30-19" tabindex="-1"></a><span class="do">## The matrix of auxiliary descriptor for the testing set:</span></span>
<span id="cb30-20"><a href="#cb30-20" tabindex="-1"></a><span class="fu">cbind</span>(</span>
<span id="cb30-21"><a href="#cb30-21" tabindex="-1"></a>  <span class="fu">predict</span>(plist[[<span class="st">&quot;Depth&quot;</span>]], <span class="at">newdata=</span>salmon[test,<span class="st">&quot;Depth&quot;</span>]),</span>
<span id="cb30-22"><a href="#cb30-22" tabindex="-1"></a>  <span class="fu">predict</span>(plist[[<span class="st">&quot;Velocity&quot;</span>]], <span class="at">newdata=</span>salmon[test,<span class="st">&quot;Velocity&quot;</span>]),</span>
<span id="cb30-23"><a href="#cb30-23" tabindex="-1"></a>  <span class="fu">predict</span>(plist[[<span class="st">&quot;Substrate&quot;</span>]], <span class="at">newdata=</span>salmon[test,<span class="st">&quot;Substrate&quot;</span>])</span>
<span id="cb30-24"><a href="#cb30-24" tabindex="-1"></a>) <span class="ot">-&gt;</span> ww</span>
<span id="cb30-25"><a href="#cb30-25" tabindex="-1"></a></span>
<span id="cb30-26"><a href="#cb30-26" tabindex="-1"></a><span class="do">## Copying the column names:</span></span>
<span id="cb30-27"><a href="#cb30-27" tabindex="-1"></a><span class="fu">colnames</span>(ww) <span class="ot">&lt;-</span> <span class="fu">colnames</span>(w)</span></code></pre></div>
<p>The objective function is executed as follows:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb31-1"><a href="#cb31-1" tabindex="-1"></a><span class="fu">objf2</span>(</span>
<span id="cb31-2"><a href="#cb31-2" tabindex="-1"></a>  <span class="at">par =</span> <span class="fu">c</span>(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>),</span>
<span id="cb31-3"><a href="#cb31-3" tabindex="-1"></a>  <span class="at">m =</span> <span class="fu">genDistMetric</span>(),</span>
<span id="cb31-4"><a href="#cb31-4" tabindex="-1"></a>  <span class="at">fun =</span> <span class="st">&quot;Gaussian&quot;</span>,</span>
<span id="cb31-5"><a href="#cb31-5" tabindex="-1"></a>  <span class="at">x =</span> salmon<span class="sc">$</span>Position[train],</span>
<span id="cb31-6"><a href="#cb31-6" tabindex="-1"></a>  <span class="at">xx =</span> salmon<span class="sc">$</span>Position[test],</span>
<span id="cb31-7"><a href="#cb31-7" tabindex="-1"></a>  <span class="at">y =</span> salmon[[<span class="st">&quot;Abundance&quot;</span>]][train],</span>
<span id="cb31-8"><a href="#cb31-8" tabindex="-1"></a>  <span class="at">yy =</span> salmon[[<span class="st">&quot;Abundance&quot;</span>]][test],</span>
<span id="cb31-9"><a href="#cb31-9" tabindex="-1"></a>  <span class="at">w =</span> w,</span>
<span id="cb31-10"><a href="#cb31-10" tabindex="-1"></a>  <span class="at">ww =</span> ww,</span>
<span id="cb31-11"><a href="#cb31-11" tabindex="-1"></a>  <span class="at">lb =</span> <span class="fu">c</span>(<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">20</span>,<span class="fl">0.25</span>),</span>
<span id="cb31-12"><a href="#cb31-12" tabindex="-1"></a>  <span class="at">ub=</span><span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1000</span>,<span class="fl">1.75</span>)</span>
<span id="cb31-13"><a href="#cb31-13" tabindex="-1"></a>) <span class="ot">-&gt;</span> res2</span>
<span id="cb31-14"><a href="#cb31-14" tabindex="-1"></a></span>
<span id="cb31-15"><a href="#cb31-15" tabindex="-1"></a>res2</span></code></pre></div>
<pre><code>## [1] 135.7557</code></pre>
<p>yielding a parr abundance model with an out of the sample deviance of
<span class="math inline">\(135.8\)</span>.</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb33-1"><a href="#cb33-1" tabindex="-1"></a>estimateSEF2 <span class="ot">&lt;-</span> <span class="cf">function</span>(x, xx, y, yy, w, ww, lower, upper) {</span>
<span id="cb33-2"><a href="#cb33-2" tabindex="-1"></a>  </span>
<span id="cb33-3"><a href="#cb33-3" tabindex="-1"></a>  res <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="at">optim =</span> <span class="fu">list</span>())  <span class="do">## A list to contain the results.</span></span>
<span id="cb33-4"><a href="#cb33-4" tabindex="-1"></a>  </span>
<span id="cb33-5"><a href="#cb33-5" tabindex="-1"></a>  <span class="do">## This loop tries the seven DWF one by one, estimating &#39;dmax&#39; (and, when</span></span>
<span id="cb33-6"><a href="#cb33-6" tabindex="-1"></a>  <span class="do">## necessary, &#39;shape&#39;) using simulated annealing.</span></span>
<span id="cb33-7"><a href="#cb33-7" tabindex="-1"></a>  <span class="cf">for</span>(fun <span class="cf">in</span> <span class="fu">c</span>(<span class="st">&quot;linear&quot;</span>,<span class="st">&quot;power&quot;</span>,<span class="st">&quot;hyperbolic&quot;</span>,<span class="st">&quot;spherical&quot;</span>,<span class="st">&quot;exponential&quot;</span>,</span>
<span id="cb33-8"><a href="#cb33-8" tabindex="-1"></a>               <span class="st">&quot;Gaussian&quot;</span>,<span class="st">&quot;hole_effect&quot;</span>)) {</span>
<span id="cb33-9"><a href="#cb33-9" tabindex="-1"></a>    <span class="fu">optim</span>(</span>
<span id="cb33-10"><a href="#cb33-10" tabindex="-1"></a>      <span class="at">par =</span> <span class="fu">c</span>(<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="cf">if</span>(fun <span class="sc">%in%</span> <span class="fu">c</span>(<span class="st">&quot;power&quot;</span>,<span class="st">&quot;hyperbolic&quot;</span>)) <span class="dv">0</span>), <span class="at">fn =</span> objf2,</span>
<span id="cb33-11"><a href="#cb33-11" tabindex="-1"></a>      <span class="at">method =</span> <span class="st">&quot;SANN&quot;</span>, <span class="at">m =</span> <span class="fu">genDistMetric</span>(), <span class="at">fun =</span> fun,</span>
<span id="cb33-12"><a href="#cb33-12" tabindex="-1"></a>      <span class="at">x =</span> x, <span class="at">xx =</span> xx, <span class="at">y =</span> y, <span class="at">yy =</span> yy, <span class="at">w =</span> w, <span class="at">ww =</span> ww,</span>
<span id="cb33-13"><a href="#cb33-13" tabindex="-1"></a>      <span class="at">lb =</span> <span class="fu">c</span>(lower[<span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>],<span class="cf">if</span>(fun <span class="sc">%in%</span> <span class="fu">c</span>(<span class="st">&quot;power&quot;</span>,<span class="st">&quot;hyperbolic&quot;</span>)) lower[<span class="dv">4</span>]),</span>
<span id="cb33-14"><a href="#cb33-14" tabindex="-1"></a>      <span class="at">ub =</span> <span class="fu">c</span>(upper[<span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>],<span class="cf">if</span>(fun <span class="sc">%in%</span> <span class="fu">c</span>(<span class="st">&quot;power&quot;</span>,<span class="st">&quot;hyperbolic&quot;</span>)) upper[<span class="dv">4</span>])</span>
<span id="cb33-15"><a href="#cb33-15" tabindex="-1"></a>    ) <span class="ot">-&gt;</span> res<span class="sc">$</span>optim[[fun]]</span>
<span id="cb33-16"><a href="#cb33-16" tabindex="-1"></a>  }</span>
<span id="cb33-17"><a href="#cb33-17" tabindex="-1"></a>  </span>
<span id="cb33-18"><a href="#cb33-18" tabindex="-1"></a>  <span class="do">## Extract the minimum values from the list of optimization:</span></span>
<span id="cb33-19"><a href="#cb33-19" tabindex="-1"></a>  <span class="fu">unlist</span>(</span>
<span id="cb33-20"><a href="#cb33-20" tabindex="-1"></a>    <span class="fu">lapply</span>(</span>
<span id="cb33-21"><a href="#cb33-21" tabindex="-1"></a>      res<span class="sc">$</span>optim,</span>
<span id="cb33-22"><a href="#cb33-22" tabindex="-1"></a>      <span class="cf">function</span>(x) x<span class="sc">$</span>value</span>
<span id="cb33-23"><a href="#cb33-23" tabindex="-1"></a>    )</span>
<span id="cb33-24"><a href="#cb33-24" tabindex="-1"></a>  ) <span class="ot">-&gt;</span> res<span class="sc">$</span>bestval</span>
<span id="cb33-25"><a href="#cb33-25" tabindex="-1"></a>  </span>
<span id="cb33-26"><a href="#cb33-26" tabindex="-1"></a>  <span class="do">## Find which DWF had the minimum objective criterion value:</span></span>
<span id="cb33-27"><a href="#cb33-27" tabindex="-1"></a>  <span class="fu">names</span>(</span>
<span id="cb33-28"><a href="#cb33-28" tabindex="-1"></a>    <span class="fu">which.min</span>(</span>
<span id="cb33-29"><a href="#cb33-29" tabindex="-1"></a>      res<span class="sc">$</span>bestval</span>
<span id="cb33-30"><a href="#cb33-30" tabindex="-1"></a>    )</span>
<span id="cb33-31"><a href="#cb33-31" tabindex="-1"></a>  ) <span class="ot">-&gt;</span> res<span class="sc">$</span>fun</span>
<span id="cb33-32"><a href="#cb33-32" tabindex="-1"></a>  </span>
<span id="cb33-33"><a href="#cb33-33" tabindex="-1"></a>  <span class="do">## Back-transform the parameter values:</span></span>
<span id="cb33-34"><a href="#cb33-34" tabindex="-1"></a>  res <span class="sc">%&gt;%</span></span>
<span id="cb33-35"><a href="#cb33-35" tabindex="-1"></a>    {.<span class="sc">$</span>optim[[.<span class="sc">$</span>fun]]<span class="sc">$</span>par} <span class="sc">%&gt;%</span></span>
<span id="cb33-36"><a href="#cb33-36" tabindex="-1"></a>    {(upper[<span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(.)] <span class="sc">-</span> lower[<span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(.)]) <span class="sc">*</span> (<span class="dv">1</span> <span class="sc">+</span> <span class="fu">exp</span>(<span class="sc">-</span>.))<span class="sc">^</span>(<span class="sc">-</span><span class="dv">1</span>) <span class="sc">+</span></span>
<span id="cb33-37"><a href="#cb33-37" tabindex="-1"></a>        lower[<span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(.)]} <span class="ot">-&gt;</span> res<span class="sc">$</span>par</span>
<span id="cb33-38"><a href="#cb33-38" tabindex="-1"></a>  </span>
<span id="cb33-39"><a href="#cb33-39" tabindex="-1"></a>  <span class="do">## Calculate the SEF using the optimized DWF parameters:</span></span>
<span id="cb33-40"><a href="#cb33-40" tabindex="-1"></a>  res <span class="sc">%&gt;%</span></span>
<span id="cb33-41"><a href="#cb33-41" tabindex="-1"></a>    {<span class="fu">genSEF</span>(</span>
<span id="cb33-42"><a href="#cb33-42" tabindex="-1"></a>      <span class="at">x =</span> x,</span>
<span id="cb33-43"><a href="#cb33-43" tabindex="-1"></a>      <span class="at">m =</span> <span class="fu">genDistMetric</span>(),</span>
<span id="cb33-44"><a href="#cb33-44" tabindex="-1"></a>      <span class="at">f =</span> <span class="fu">genDWF</span>(.<span class="sc">$</span>fun, .<span class="sc">$</span>par[<span class="dv">3</span>], <span class="cf">if</span>(<span class="fu">length</span>(.<span class="sc">$</span>par) <span class="sc">&gt;</span> <span class="dv">3</span>) .<span class="sc">$</span>par[<span class="dv">4</span>])</span>
<span id="cb33-45"><a href="#cb33-45" tabindex="-1"></a>    )} <span class="ot">-&gt;</span> res<span class="sc">$</span>sef</span>
<span id="cb33-46"><a href="#cb33-46" tabindex="-1"></a>  </span>
<span id="cb33-47"><a href="#cb33-47" tabindex="-1"></a>  <span class="do">## Return the result list:</span></span>
<span id="cb33-48"><a href="#cb33-48" tabindex="-1"></a>  res</span>
<span id="cb33-49"><a href="#cb33-49" tabindex="-1"></a>}</span></code></pre></div>
<p>We can now estimate the optimal SEF for modelling parr abundance as
follows:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb34-1"><a href="#cb34-1" tabindex="-1"></a><span class="fu">estimateSEF2</span>(</span>
<span id="cb34-2"><a href="#cb34-2" tabindex="-1"></a>  <span class="at">x =</span> salmon<span class="sc">$</span>Position[train],</span>
<span id="cb34-3"><a href="#cb34-3" tabindex="-1"></a>  <span class="at">xx =</span> salmon<span class="sc">$</span>Position[test],</span>
<span id="cb34-4"><a href="#cb34-4" tabindex="-1"></a>  <span class="at">y =</span> salmon[[<span class="st">&quot;Abundance&quot;</span>]][train],</span>
<span id="cb34-5"><a href="#cb34-5" tabindex="-1"></a>  <span class="at">yy =</span> salmon[[<span class="st">&quot;Abundance&quot;</span>]][test],</span>
<span id="cb34-6"><a href="#cb34-6" tabindex="-1"></a>  <span class="at">w =</span> w,</span>
<span id="cb34-7"><a href="#cb34-7" tabindex="-1"></a>  <span class="at">ww =</span> ww,</span>
<span id="cb34-8"><a href="#cb34-8" tabindex="-1"></a>  <span class="at">lower =</span> <span class="fu">c</span>(<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">20</span>,<span class="fl">0.25</span>),</span>
<span id="cb34-9"><a href="#cb34-9" tabindex="-1"></a>  <span class="at">upper =</span> <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1000</span>,<span class="fl">1.75</span>)</span>
<span id="cb34-10"><a href="#cb34-10" tabindex="-1"></a>) <span class="ot">-&gt;</span> sefTrain[[<span class="st">&quot;Abundance&quot;</span>]]</span></code></pre></div>
<p>The best DWF found has been <em>hole_effect</em>, with an <span class="math inline">\(\alpha\)</span> of <span class="math inline">\(0.993\)</span>, a <span class="math inline">\(\lambda\)</span> of <span class="math inline">\(0.1054\)</span>, and a <span class="math inline">\(d_{max}\)</span> of <span class="math inline">\(91\,\mathrm{m}\)</span>.</p>
<p>The elasticnet model is estimated as follows:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb35-1"><a href="#cb35-1" tabindex="-1"></a><span class="fu">cbind</span>(w, <span class="fu">as.matrix</span>(sefTrain[[<span class="st">&quot;Abundance&quot;</span>]]<span class="sc">$</span>sef)) <span class="sc">%&gt;%</span></span>
<span id="cb35-2"><a href="#cb35-2" tabindex="-1"></a>  <span class="fu">glmnet</span>(</span>
<span id="cb35-3"><a href="#cb35-3" tabindex="-1"></a>    <span class="at">y =</span> salmon<span class="sc">$</span>Abundance[train], <span class="at">family =</span> <span class="st">&quot;poisson&quot;</span>,</span>
<span id="cb35-4"><a href="#cb35-4" tabindex="-1"></a>    <span class="at">alpha =</span> sefTrain[[<span class="st">&quot;Abundance&quot;</span>]]<span class="sc">$</span>par[<span class="dv">1</span><span class="dt">L</span>],</span>
<span id="cb35-5"><a href="#cb35-5" tabindex="-1"></a>    <span class="at">lambda =</span> sefTrain[[<span class="st">&quot;Abundance&quot;</span>]]<span class="sc">$</span>par[<span class="dv">2</span><span class="dt">L</span>]) <span class="ot">-&gt;</span> lm[[<span class="st">&quot;Abundance&quot;</span>]]</span>
<span id="cb35-6"><a href="#cb35-6" tabindex="-1"></a></span>
<span id="cb35-7"><a href="#cb35-7" tabindex="-1"></a><span class="do">## Model coefficients:</span></span>
<span id="cb35-8"><a href="#cb35-8" tabindex="-1"></a><span class="fu">coef</span>(lm[[<span class="st">&quot;Abundance&quot;</span>]])</span></code></pre></div>
<pre><code>## 31 x 1 sparse Matrix of class &quot;dgCMatrix&quot;
##                      s0
## (Intercept)  0.48775321
## Depth^1      .         
## Depth^2      .         
## Velocity^1   .         
## Velocity^2   .         
## Substrate^1  0.77749010
## Substrate^2  .         
## pMEM_1       0.56231401
## pMEM_2      -0.42979149
## pMEM_3       2.60281237
## pMEM_4       0.59190038
## pMEM_5      -1.33793350
## pMEM_6       0.69311351
## pMEM_7       .         
## pMEM_8       1.12570665
## pMEM_9      -0.32720176
## pMEM_10      .         
## pMEM_11      .         
## pMEM_12      0.14375648
## pMEM_13     -0.24449250
## pMEM_14     -0.38446542
## pMEM_15     -0.70611753
## pMEM_16     -2.64039180
## pMEM_17      .         
## pMEM_18      0.58608499
## pMEM_19     -0.27411596
## pMEM_20     -0.13680399
## pMEM_21      0.75884282
## pMEM_22      2.06077847
## pMEM_23     -0.08334478
## pMEM_24     -0.38344153</code></pre>
<p>the continuous predictions are obtained as follows:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb37-1"><a href="#cb37-1" tabindex="-1"></a>lm[[<span class="st">&quot;Abundance&quot;</span>]] <span class="sc">%&gt;%</span></span>
<span id="cb37-2"><a href="#cb37-2" tabindex="-1"></a>  <span class="fu">predict</span>(</span>
<span id="cb37-3"><a href="#cb37-3" tabindex="-1"></a>    <span class="fu">cbind</span>(</span>
<span id="cb37-4"><a href="#cb37-4" tabindex="-1"></a>      <span class="fu">predict</span>(plist[[<span class="st">&quot;Depth&quot;</span>]], prd[[<span class="st">&quot;Depth&quot;</span>]]),</span>
<span id="cb37-5"><a href="#cb37-5" tabindex="-1"></a>      <span class="fu">predict</span>(plist[[<span class="st">&quot;Velocity&quot;</span>]], prd[[<span class="st">&quot;Velocity&quot;</span>]]),</span>
<span id="cb37-6"><a href="#cb37-6" tabindex="-1"></a>      <span class="fu">predict</span>(plist[[<span class="st">&quot;Substrate&quot;</span>]], prd[[<span class="st">&quot;Substrate&quot;</span>]]),</span>
<span id="cb37-7"><a href="#cb37-7" tabindex="-1"></a>      <span class="fu">predict</span>(sefTrain[[<span class="st">&quot;Abundance&quot;</span>]]<span class="sc">$</span>sef, xx)</span>
<span id="cb37-8"><a href="#cb37-8" tabindex="-1"></a>    ),</span>
<span id="cb37-9"><a href="#cb37-9" tabindex="-1"></a>    <span class="at">type=</span><span class="st">&quot;response&quot;</span></span>
<span id="cb37-10"><a href="#cb37-10" tabindex="-1"></a>  ) <span class="ot">-&gt;</span>  prd[[<span class="st">&quot;Abundance&quot;</span>]]</span></code></pre></div>
<p>and the results are displayed as follows:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb38-1"><a href="#cb38-1" tabindex="-1"></a><span class="fu">plot</span>(<span class="at">x=</span>xx, <span class="at">y=</span>prd[[<span class="st">&quot;Abundance&quot;</span>]], <span class="at">type=</span><span class="st">&quot;l&quot;</span>,</span>
<span id="cb38-2"><a href="#cb38-2" tabindex="-1"></a>     <span class="at">ylim=</span><span class="fu">range</span>(salmon[[<span class="st">&quot;Abundance&quot;</span>]], prd[[<span class="st">&quot;Abundance&quot;</span>]]), <span class="at">las=</span><span class="dv">1</span>,</span>
<span id="cb38-3"><a href="#cb38-3" tabindex="-1"></a>     <span class="at">ylab=</span><span class="st">&quot;Parr abundance (fish)&quot;</span>,</span>
<span id="cb38-4"><a href="#cb38-4" tabindex="-1"></a>     <span class="at">xlab=</span><span class="st">&quot;Location along the transect (m)&quot;</span>)</span>
<span id="cb38-5"><a href="#cb38-5" tabindex="-1"></a><span class="fu">points</span>(<span class="at">x =</span> salmon<span class="sc">$</span>Position[train], <span class="at">y =</span> salmon[[<span class="st">&quot;Abundance&quot;</span>]][train], <span class="at">pch=</span><span class="dv">21</span>,</span>
<span id="cb38-6"><a href="#cb38-6" tabindex="-1"></a>       <span class="at">bg=</span><span class="st">&quot;black&quot;</span>)</span>
<span id="cb38-7"><a href="#cb38-7" tabindex="-1"></a><span class="fu">points</span>(<span class="at">x =</span> salmon<span class="sc">$</span>Position[test], <span class="at">y =</span> salmon[[<span class="st">&quot;Abundance&quot;</span>]][test], <span class="at">pch=</span><span class="dv">21</span>,</span>
<span id="cb38-8"><a href="#cb38-8" tabindex="-1"></a>       <span class="at">bg=</span><span class="st">&quot;red&quot;</span>)</span></code></pre></div>
<p><img role="img" src="data:image/png;base64,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" /><!-- --></p>
</div>
</div>
<div id="references" class="section level1 unnumbered">
<h1 class="unnumbered">References</h1>
<div id="refs" class="references csl-bib-body hanging-indent" entry-spacing="0">
<div id="ref-Dray2006" class="csl-entry">
Dray, S., P. Legendre, and P. R. Peres-Neto. 2006. <span>“Spatial
Modelling: A Comprehensive Framework for Principal Coordinate Analysis
of Neighbour Matrices (PCNM).”</span> <em>Ecological Modelling</em>,
483–93. <a href="https://doi.org/10.1016/j.ecolmodel.2006.02.015">https://doi.org/10.1016/j.ecolmodel.2006.02.015</a>.
</div>
<div id="ref-Moran1948" class="csl-entry">
Moran, P. A. P. 1948. <span>“The Interpretation of Statistical
Maps.”</span> <em>Journal of the Royal Statistical Society: Series B
(Methodological)</em> 10: 243–51. <a href="https://doi.org/10.1111/j.2517-6161.1948.tb00012.x">https://doi.org/10.1111/j.2517-6161.1948.tb00012.x</a>.
</div>
<div id="ref-Moran1950" class="csl-entry">
———. 1950. <span>“Notes on Continuous Stochastic Phenomena.”</span>
<em>Biometrika</em> 37: 17–23. <a href="https://doi.org/10.1093/biomet/37.1-2.17">https://doi.org/10.1093/biomet/37.1-2.17</a>.
</div>
</div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
